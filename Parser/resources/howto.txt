Parsertools Overview
====================

V 0.1, april 18, 2016

Features
--------

Parsertools is a framework for building parsers.

Notable features are:

- a Parsertool parser is normally based on a given grammar, typically specified in a BNF-like notation.
- a parsed expression is represented as a nested object structure ("parse object"). Each of its (sub)object corresponds to a production
rule from the grammar that was matched by a (sub)expression encountered during parsing.
- for each production rule in the grammar a custom object type (class) is generated by the framework.
- this class can be instantiated with any string that matches the corresponding production rule (in its entirety).
- there are methods to navigate the parse object based on object type and on string value
- subproductions of a production can be adorned with "labels" that give an additional way of navigating the parse object, and that allow
"dot access" (read only) to subobjects carrying a label
- (sub)objects can be changed in place by providing an appropriate string that is then parsed and replaces the former content.
- (sub)objects can be rendered into an equivalent string expression according to the language syntax.
- there is a "dump" method on parse objects that gives rich information.
- parse objects classes can be subclassed to provide even more functionality. This is typically functionality
that is specific to a particular language. These subclasses can be further subclassed for even more specialized languages.
- it is built on top of pyparsing as its parsing engine

A typical use case for Parsertools is as a tool to build translators between expressions, usually in the same language. More generally,
it can be used in any scenario where in depth access to the parse tree is needed, both for informational purposes and as a starting point 
for further processing, e.g. translation/compilation to a different language.


Package Overview
----------------

The package structure is as follows.

- parsertools
	base.py	[main module, contains the basic classes and functions to build a parser]
	example.py [a short program, demonstrating key features of parsertools, making use of base.py and also of sparqlparser.py, described below]
	- parsers [subpackage, intended for actual parsers for various languages]
		sparqlparser.py	[parser for the W3C sparql language (https://www.w3.org/TR/2013/REC-sparql11-query-20130321/)]
		(others, to be added)
		

How to construct a parser
-------------------------

Note: For this implementation, a Python version >= 3.3 is mandatory.

A parser is mainly defined by defining pyparsing patterns for its syntax. An example can be found as sparqlparser.py (which has additional functionality 
related to the SPARQL language, not covered here).

Typically, this syntax would be given as a list of (E/A)BNF productions. In that case, proceed as follows.
The following guidlines are for the simple case, where it is sufficient to parse expressions according to the syntax without further pre- or post processing.
This will provide parsing into a nested parse object, with full dump functionality, replacement of subexpressions, etc.

This procedure results in a python module. It is recommended to place that in pyparsing.parsers, but it can live anywhere.

1. Order the production rules from low level to high level constructs, with as little forward references as possible.
2. In this way, a list of terminal productions comes first, followed by a number of non-terminals. It is a matter of taste whether to add patterns for keywords, delimiters etc. 
or whether to include them as Literals in the patterns. If defined as patterns, they can act as search keys in the parse object.
3. Start the module with a few imports from parsertools and from parsertools.base
4. Create a Parser object. This has an optional parameter which if used must be a subclass of the ParseStruct class, defined in base.py. There is a short formula
to create the object, which must appear early in the module. If a subclass of ParseStruct is desired (for special language processing needs), its definition
must be available at this point. The default case is when no parameter is specified, in which case the parser is constructed based on the ParseStruct class.
5. For every rule in the grammar list, define a pyparsing pattern that accepts all valid expressions for that rule and none other. It must consume
the whole expression. Give it a meaningful name, such as the name of the grammar rule it represents. Use setName() to define a name for the class that will be 
generated as described in the next item. You can use the samen name for this - there will be no name clash with the pattern name.
6. After each pattern definition, call the method addElement from the Parser object to register the pattern. As a side effect, a class is generated that will be
the main tool to both parse (sub)expressions and to represent them in the parse tree. This class will be an attribute of the parser, and carries the name
specified in setName() as described above.
7. Add further methods specific for the language, as desired. This is not needed for the standard case.
8. Optionally, setResultsName() can be used to specify "labels" for parts of the parsed (sub)expression. These labels will show up in the dump for informational purposes,
can be used to navigate the parse object, and can be used for "dot" read access to subexpressions. Only elements corresponding to other grammar rules may be labeled in this way.
9. A judicious use of Group constructs is recommended to isolate various subparts, in particular when labeled. Examples can be found in sparqlparser.py. 
10. Basically, this is all that is needed to create a parser for your language.


How to use your parser
----------------------

A short usage example can be found in example.py. (To be extended.)
